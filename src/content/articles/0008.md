---
title: Rustã§ä¿¡å·å‡¦ç†ã‚’ã—ãŸã„
description: Rustã§ä¿¡å·å‡¦ç†ã‚’è¡Œã†ãŸã‚ã®å‰æ®µéšã¨ã—ã¦, Rustã§WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†æ–¹æ³•ã‚’èª¿æŸ»ã—ã¾ã—ãŸ.
category: [Rust]
createdAt: 2024-01-05
updatedAt: 2024-01-05
draft: false
---

## ã¯ã˜ã‚ã«

æ­£æœˆä¼‘ã¿ã«æš‡ã‚’æŒã¦ä½™ã—ã¦ã„ãŸã®ã§, æš‡ã¤ã¶ã—ã«Rustã§ä¿¡å·å‡¦ç†ã‚’ã—ã‚ˆã†ã¨æ€ã„ç«‹ã¡ã¾ã—ãŸ.
ä¿¡å·å‡¦ç†ã®èµ°ã‚Šã¨ã—ã¦, WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†æ–¹æ³•ã‚’èª¿æŸ»ã—ãŸã®ã§, ãã®ãƒ¡ãƒ¢ã§ã™.

## WAVãƒ•ã‚¡ã‚¤ãƒ«ã®æ§‹é€ 

WAVãƒ•ã‚¡ã‚¤ãƒ«ã¯Microsoftã®RIFF(Resource Interchange File Format)ã®ã‚µãƒ–ã‚»ãƒƒãƒˆã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™.
WAVã¯MP3ã‚„AACãªã©ã®åœ§ç¸®éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã¯ç•°ãªã‚Š, éåœ§ç¸®ã®éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™.
éå¸¸ã«ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§, èª­ã¿è¾¼ã¿ã‚„æ›¸ãè¾¼ã¿ãŒå®¹æ˜“ãªã®ã§ä¿¡å·å‡¦ç†ã§ã‚ˆãä½¿ç”¨ã•ã‚Œã¾ã™.

WAVãƒ•ã‚¡ã‚¤ãƒ«ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªæ§‹é€ ã‚’ã—ã¦ã„ã¾ã™.

| description  | field name    | endian | file offset |    field size |
| :----------- | :------------ | :----- | ----------: | ------------: |
| RIFFãƒ˜ãƒƒãƒ€ãƒ¼ | ChunkID       | big    |           0 |             4 |
|              | ChunkSize     | little |           4 |             4 |
|              | Format        | big    |           8 |             4 |
| fmtãƒãƒ£ãƒ³ã‚¯  | Subchunk1ID   | big    |          12 |             4 |
|              | Subchunk1Size | little |          16 |             4 |
|              | AudioFormat   | little |          20 |             2 |
|              | NumChannels   | little |          22 |             2 |
|              | SampleRate    | little |          24 |             4 |
|              | ByteRate      | little |          28 |             4 |
|              | BlockAlign    | little |          32 |             2 |
|              | BitsPerSample | little |          34 |             2 |
| Dataãƒãƒ£ãƒ³ã‚¯ | Subchunk2ID   | big    |          36 |             4 |
|              | Subchunk2Size | little |          40 |             4 |
|              | Data          | little |          44 | Subchunk2Size |

Rustã®æ§‹é€ ä½“ã‚’ä½¿ã£ã¦ã“ã®æ§‹é€ ã‚’è¡¨ç¾ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™.

```rust
struct RiffDescChunk {
    id: [u8; 4],
    size: u32,
    form_type: [u8; 4],
}

struct FmtChunk {
    id: [u8; 4],
    size: u32,
    audio_format: u16,
    num_channels: u16,
    sample_rate: u32,
    byte_rate: u32,
    block_align: u16,
    bits_per_sample: u16,
}

struct DataChunk {
    id: [u8; 4],
    size: u32,
    data: Vec<i16>,
}
```

> [!WARNING]
> `DataChunk`ã®`data`ã‚’`Vec<i16>`ã¨ã—ã¦ã„ã‚‹ã®ã¯, ãƒ“ãƒƒãƒˆæ·±åº¦ã‚’16bitã¨æ±ºã‚æ‰“ã¡ã—ã¦ã„ã‚‹ãŸã‚ã§ã™.(æœ¬å½“ã¯ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ã£ã¦å¯å¤‰ã«ã—ãŸæ–¹ãŒè‰¯ã„ã‹ã‚‚ã—ã‚Œãªã„)

ã“ã‚Œã‚‰ã®Chunkã®å…±é€šå®Ÿè£…ã¨ã—ã¦, `Chunk`ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®šç¾©ã—ã¾ã™.

```rust
trait Chunk {
    fn to_bytes(&self) -> Vec<u8>;
}


impl Chunk for RiffDescChunk {
    fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(&self.id);
        bytes.extend_from_slice(&self.size.to_le_bytes());
        bytes.extend_from_slice(&self.form_type);
        bytes
    }
}

impl Chunk for FmtChunk {
    fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(&self.id);
        bytes.extend_from_slice(&self.size.to_le_bytes());
        bytes.extend_from_slice(&self.audio_format.to_le_bytes());
        bytes.extend_from_slice(&self.num_channels.to_le_bytes());
        bytes.extend_from_slice(&self.sample_rate.to_le_bytes());
        bytes.extend_from_slice(&self.byte_rate.to_le_bytes());
        bytes.extend_from_slice(&self.block_align.to_le_bytes());
        bytes.extend_from_slice(&self.bits_per_sample.to_le_bytes());
        bytes
    }
}


impl Chunk for DataChunk {
    fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        bytes.extend_from_slice(&self.id);
        bytes.extend_from_slice(&self.size.to_le_bytes());
        bytes.extend_from_slice(
            &self
                .data
                .iter()
                .flat_map(|&s| s.to_le_bytes())
                .collect::<Vec<u8>>(),
        );
        bytes
    }
}
```

å°‘ã—å†—é•·ã§ã™ãŒ, ã“ã‚Œã§WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†ãŸã‚ã®åŸºæœ¬çš„ãªæ§‹é€ ä½“ã¨ãƒˆãƒ¬ã‚¤ãƒˆãŒå®šç¾©ã§ãã¾ã—ãŸ.

## WAVãƒ•ã‚¡ã‚¤ãƒ«ã®æ›¸ãå‡ºã—

è©¦ã—ã«, sinæ³¢ã‚’æ›¸ãå‡ºã—ã¦ã¿ã¾ã™.

```rust
use std::f32::consts::PI;
use std::fs::File;
use std::io::Write;

// WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«é–¢ã™ã‚‹å®šæ•°
const SAMPLE_RATE: u32 = 44100;
const BITS_PER_SAMPLE: u16 = 16; // ã‚µãƒ³ãƒ—ãƒ«ã‚ãŸã‚Šã®ãƒ“ãƒƒãƒˆæ•°
const NUM_CHANNELS: u16 = 1; // ãƒãƒ£ãƒãƒ«æ•°ï¼ˆãƒ¢ãƒãƒ©ãƒ«ï¼‰
const LINEAR_PCM_FORMAT: u16 = 1; // PCMãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
const FMT_CHUNK_SIZE: u32 = 16;

// ã‚µãƒ³ãƒ—ãƒ«ã®ç”Ÿæˆã«ä½¿ç”¨ã™ã‚‹å®šæ•°
const DURATION_SECS: f32 = 2.0; // éŸ³ã®å†ç”Ÿæ™‚é–“ï¼ˆç§’ï¼‰
const AMPLITUDE: f32 = std::i16::MAX as f32; // éŸ³ã®æŒ¯å¹…
const FREQUENCY: f32 = 440.0; // ç”Ÿæˆã™ã‚‹éŸ³ã®å‘¨æ³¢æ•°ï¼ˆHzï¼‰

// ã‚µãƒ³ãƒ—ãƒ«ç”Ÿæˆé–¢æ•°
fn generate_samples(duration: u32, frequency: f32, amplitude: f32) -> Vec<i16> {
    (0..duration)
        .map(|i| {
            let t = i as f32 / SAMPLE_RATE as f32;
            let sample = amplitude * (2.0 * PI * frequency * t).sin();
            sample as i16
        })
        .collect()
}

fn main() {
    // ã‚µãƒ³ãƒ—ãƒ«ã‚’ç”Ÿæˆ
    let duration_samples = (DURATION_SECS * SAMPLE_RATE as f32) as u32;
    let samples = generate_samples(duration_samples, FREQUENCY, AMPLITUDE);

    // Dataãƒãƒ£ãƒ³ã‚¯ã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
    let data_chunk_size = 2 * samples.len() as u32; // ã‚µãƒ³ãƒ—ãƒ«æ•° x 2ãƒã‚¤ãƒˆï¼ˆ16ãƒ“ãƒƒãƒˆï¼‰
    let riff_size = 36 + data_chunk_size; // RIFFãƒãƒ£ãƒ³ã‚¯å…¨ä½“ã®ã‚µã‚¤ã‚º

    // RIFFãƒ˜ãƒƒãƒ€ãƒ¼
    let riff_desc_header = RiffDescChunk {
        id: *b"RIFF",
        size: riff_size,
        form_type: *b"WAVE",
    };

    // ãƒ–ãƒ­ãƒƒã‚¯ã‚¢ãƒ©ã‚¤ãƒ³ãƒ¡ãƒ³ãƒˆã¨ãƒã‚¤ãƒˆãƒ¬ãƒ¼ãƒˆã®è¨ˆç®—
    let block_align = NUM_CHANNELS * BITS_PER_SAMPLE / 8; // ãƒãƒ£ãƒ³ãƒãƒ«æ•° x ã‚µãƒ³ãƒ—ãƒ«ã‚ãŸã‚Šã®ãƒã‚¤ãƒˆæ•°
    let byte_rate = SAMPLE_RATE * block_align as u32; // ã‚µãƒ³ãƒ—ãƒ«ãƒ¬ãƒ¼ãƒˆ x ãƒ–ãƒ­ãƒƒã‚¯ã‚¢ãƒ©ã‚¤ãƒ³ãƒ¡ãƒ³ãƒˆ

    // fmtãƒãƒ£ãƒ³ã‚¯
    let fmt_chunk = FmtChunk {
        id: *b"fmt ",
        size: FMT_CHUNK_SIZE,
        audio_format: LINEAR_PCM_FORMAT,
        num_channels: NUM_CHANNELS,
        sample_rate: SAMPLE_RATE,
        byte_rate,
        block_align,
        bits_per_sample: BITS_PER_SAMPLE,
    };

    // dataãƒãƒ£ãƒ³ã‚¯
    let data_chunk = DataChunk {
        id: *b"data",
        size: data_chunk_size,
        data: samples,
    };

    // WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ç”Ÿæˆ
    let mut file = File::create("test.wav").unwrap();
    file.write_all(&riff_desc_header.to_bytes()).unwrap();
    file.write_all(&fmt_chunk.to_bytes()).unwrap();
    file.write_all(&data_chunk.to_bytes()).unwrap();
    file.flush().unwrap();
}
```

ã“ã‚Œã§, `test.wav`ã¨ã„ã†ãƒ•ã‚¡ã‚¤ãƒ«ãŒç”Ÿæˆã•ã‚Œã¾ã™.

ç”Ÿæˆã•ã‚ŒãŸWAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’[audacity](https://www.audacityteam.org/)ã§èª­ã¿è¾¼ã‚€ã¨, ä»¥ä¸‹ã®ã‚ˆã†ã«sinæ³¢ãŒè¡¨ç¤ºã•ã‚Œã¾ã™.
æ³¢å½¢, ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã¨ã‚‚ã«æœŸå¾…å€¤é€šã‚Šã§ã™ã­.
ã¾ãŸæ­£å¸¸ã«éŸ³ãŒå†ç”Ÿã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ãŸ.

> [!TIP]
> t=0ä»˜è¿‘ã¯ä¸é€£ç¶šãªã®ã§ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ãŒä¹±ã‚Œã¦ã„ã¾ã™.  
> ã“ã‚Œã¯çª“é–¢æ•°ã‚’ã‹ã‘ã‚‹ã“ã¨ã§æ”¹å–„ã§ãã¾ã™.

![audacity](https://res.cloudinary.com/dlsmszcqb/image/upload/v1704470180/blog/Articles/0008/aloe7dn3nnteitco0tmp.webp)

ä¸€å¿œ, ç”Ÿæˆã•ã‚ŒãŸWAVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒã‚¤ãƒŠãƒªã‚’é–‹ã„ã¦ä¸­èº«ã‚’ç¢ºèªã—ã¦ã¿ã¾ã™.

```plaintext
00000000: 5249 4646 34b1 0200 5741 5645 666d 7420  RIFF4...WAVEfmt
00000010: 1000 0000 0100 0100 44ac 0000 8858 0100  ........D....X..
00000020: 0200 1000 6461 7461 10b1 0200 0000 0408  ....data........
...
```

big endianã¨little endianãŒæ··ã–ã£ã¦èª­ã¿ã«ãã„ã§ã™ãŒ, ç”Ÿæˆã•ã‚ŒãŸWAVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ˜ãƒƒãƒ€ãƒ¼ã‚‚ç‰¹ã«å•é¡Œãªã•ãã†ã§ã™.

```plaintext
52 49 46 46: RIFF
34 b1 02 00: 0x0002b134 = 176564[bytes]
57 41 56 45: WAVE
66 6d 74 20: fmt
10 00 00 00: 0x00000010 = 16[bytes]
01 00      : 0x0001 = 1 (PCM)
01 00      : 0x0001 = 1 (monoral)
44 ac 00 00: 0x0000ac44 = 44100[Hz]
88 58 01 00: 0x00015888 = 88200[byte/sec]
02 00      : 0x0002 = 2 (block size)
10 00      : 0x0010 = 16 (bit/sample)
64 61 74 61: data
10 b1 02 00: 0x0002b110 = 176528[bytes]

```

## ãŠã‚ã‚Šã«

Rustã§WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ã†æ–¹æ³•ã‚’èª¿æŸ»ã—ã¾ã—ãŸ.
ä½“åŠ›ãŒå°½ããŸã®ã§å®Ÿè£…ã¯ã—ã¾ã›ã‚“ã§ã—ãŸãŒ, èª­ã¿è¾¼ã¿ã¯æ›¸ãå‡ºã—ã¨åŒã˜ã‚ˆã†ãªæ„Ÿã˜ã§å®Ÿè£…ã§ãã‚‹ã¨æ€ã„ã¾ã™.
ã¡ãªã¿ã«, WAVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ‰±ãˆã‚‹ã‚¯ãƒ¬ãƒ¼ãƒˆã¯ã„ãã¤ã‹ã‚ã‚‹ã‚ˆã†ãªã®ã§, é¢å€’ãã•ããªã£ãŸã‚‰ãã¡ã‚‰ã‚’ä½¿ãŠã†ã¨æ€ã„ã¾ã™ğŸ’¦.
